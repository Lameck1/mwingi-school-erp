import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import Database from 'better-sqlite3';
import { ApprovalWorkflowService } from '../ApprovalWorkflowService';

vi.mock('../../../database/utils/audit', () => ({
  logAudit: vi.fn(),
}));

describe('ApprovalWorkflowService', () => {
  let db: Database.Database;
  let service: ApprovalWorkflowService;

  beforeEach(async () => {
    try {
      db = new Database(':memory:');

      // Create schema
      db.exec(`
        CREATE TABLE user (
          id INTEGER PRIMARY KEY,
          username TEXT UNIQUE NOT NULL,
          email TEXT UNIQUE NOT NULL,
          password_hash TEXT NOT NULL,
          first_name TEXT NOT NULL,
          last_name TEXT NOT NULL,
          role TEXT NOT NULL,
          is_active BOOLEAN DEFAULT 1,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE student (
          id INTEGER PRIMARY KEY,
          admission_number TEXT UNIQUE NOT NULL,
          first_name TEXT NOT NULL,
          last_name TEXT NOT NULL,
          email TEXT,
          phone_number TEXT,
          date_of_birth TEXT,
          gender TEXT,
          is_active BOOLEAN DEFAULT 1,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE fee_invoice (
          id INTEGER PRIMARY KEY,
          student_id INTEGER NOT NULL,
          invoice_number TEXT UNIQUE NOT NULL,
          amount_due DECIMAL(10,2) NOT NULL,
          amount_paid DECIMAL(10,2) DEFAULT 0,
          due_date TEXT,
          issue_date TEXT,
          status TEXT DEFAULT 'PENDING',
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (student_id) REFERENCES student(id)
        );

        CREATE TABLE approval_level (
          id INTEGER PRIMARY KEY,
          level_name TEXT NOT NULL,
          level_order INTEGER NOT NULL,
          amount_limit DECIMAL(10,2),
          description TEXT,
          is_active BOOLEAN DEFAULT 1,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE approval_request (
          id INTEGER PRIMARY KEY,
          request_type TEXT NOT NULL,
          request_ref TEXT UNIQUE NOT NULL,
          student_id INTEGER,
          fee_invoice_id INTEGER,
          amount DECIMAL(10,2) NOT NULL,
          status TEXT DEFAULT 'PENDING',
          current_approval_level INTEGER,
          requested_by_user_id INTEGER NOT NULL,
          request_reason TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (student_id) REFERENCES student(id),
          FOREIGN KEY (fee_invoice_id) REFERENCES fee_invoice(id),
          FOREIGN KEY (current_approval_level) REFERENCES approval_level(id),
          FOREIGN KEY (requested_by_user_id) REFERENCES user(id)
        );

        CREATE TABLE approval_history (
          id INTEGER PRIMARY KEY,
          approval_request_id INTEGER NOT NULL,
          approval_level_id INTEGER NOT NULL,
          action TEXT NOT NULL,
          approved_by_user_id INTEGER NOT NULL,
          comments TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (approval_request_id) REFERENCES approval_request(id),
          FOREIGN KEY (approval_level_id) REFERENCES approval_level(id),
          FOREIGN KEY (approved_by_user_id) REFERENCES user(id)
        );
      `);

      // Insert test data
      const userStmt = db.prepare(`
        INSERT INTO user (username, email, password_hash, first_name, last_name, role)
        VALUES (?, ?, ?, ?, ?, ?)
      `);
      userStmt.run('testuser', 'test@school.com', 'hash123', 'Test', 'User', 'admin');
      userStmt.run('approver1', 'approver1@school.com', 'hash123', 'Approver', 'One', 'approver');
      userStmt.run('approver2', 'approver2@school.com', 'hash123', 'Approver', 'Two', 'approver');
      userStmt.run('principal', 'principal@school.com', 'hash123', 'Principal', 'School', 'principal');

      const studentStmt = db.prepare(`
        INSERT INTO student (admission_number, first_name, last_name, email)
        VALUES (?, ?, ?, ?)
      `);
      studentStmt.run('STU-001', 'John', 'Doe', 'john@school.com');
      studentStmt.run('STU-002', 'Jane', 'Smith', 'jane@school.com');

      const invoiceStmt = db.prepare(`
        INSERT INTO fee_invoice (student_id, invoice_number, amount_due, due_date, issue_date)
        VALUES (?, ?, ?, ?, ?)
      `);
      invoiceStmt.run(1, 'INV-001', 5000, '2025-02-28', '2025-02-01');
      invoiceStmt.run(1, 'INV-002', 3000, '2025-03-31', '2025-03-01');
      invoiceStmt.run(2, 'INV-003', 5000, '2025-02-28', '2025-02-01');

      const levelStmt = db.prepare(`
        INSERT INTO approval_level (level_name, level_order, amount_limit, description)
        VALUES (?, ?, ?, ?)
      `);
      levelStmt.run('HOD', 1, 5000, 'Head of Department');
      levelStmt.run('Deputy Principal', 2, 10000, 'Deputy Principal Approval');
      levelStmt.run('Principal', 3, 100000, 'Principal Final Approval');

      const requestStmt = db.prepare(`
        INSERT INTO approval_request (request_type, request_ref, student_id, fee_invoice_id, amount, status, current_approval_level, requested_by_user_id, request_reason)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      requestStmt.run('FEE_WAIVER', 'REQ-001', 1, 1, 2500, 'PENDING', 1, 1, 'Hardship case');
      requestStmt.run('FEE_DISCOUNT', 'REQ-002', 2, 3, 500, 'PENDING', 1, 1, 'Early payment discount');

      service = new ApprovalWorkflowService(db);
      console.log('ApprovalWorkflowService test database initialized');
    } catch (error) {
      console.error('ApprovalWorkflowService beforeEach error:', error);
      throw error;
    }
  });

  afterEach(() => {
    if (db) {
      db.close();
    }
  });

  // createApprovalRequest tests
  it('should create new approval request', async () => {
    try {
      const result = await service.createApprovalRequest({
        requestType: 'FEE_WAIVER',
        studentId: 1,
        amount: 1000,
        reason: 'Medical reasons',
      });
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should generate unique request reference', async () => {
    try {
      const result = await service.createApprovalRequest({
        requestType: 'FEE_DISCOUNT',
        studentId: 2,
        amount: 500,
        reason: 'Scholarship',
      });
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should set initial approval level based on amount', async () => {
    try {
      const result = await service.createApprovalRequest({
        requestType: 'FEE_WAIVER',
        studentId: 1,
        amount: 3000,
        reason: 'Emergency',
      });
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should set request status to PENDING', async () => {
    try {
      const result = await service.createApprovalRequest({
        requestType: 'FEE_WAIVER',
        studentId: 1,
        amount: 2000,
        reason: 'Test case',
      });
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  // submitForApproval tests
  it('should submit approval request to current level', async () => {
    try {
      const result = await service.submitForApproval(1, 1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should record approval level and timestamp', async () => {
    try {
      const result = await service.submitForApproval(1, 1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  // approveRequest tests
  it('should approve approval request at current level', async () => {
    try {
      const result = await service.approveRequest(1, 1, 'Approved - Justified');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should advance to next approval level on approval', async () => {
    try {
      const result = await service.approveRequest(1, 1, 'Approved');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should mark request as APPROVED if final level', async () => {
    try {
      const result = await service.approveRequest(1, 1, 'Final approval');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  // rejectRequest tests
  it('should reject approval request with reason', async () => {
    try {
      const result = await service.rejectRequest(1, 1, 'Insufficient documentation');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should mark request as REJECTED', async () => {
    try {
      const result = await service.rejectRequest(1, 1, 'Not eligible');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should store rejection reason in history', async () => {
    try {
      const result = await service.rejectRequest(1, 1, 'Policy violation');
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  // getApprovalRequestStatus tests
  it('should retrieve approval request status', async () => {
    try {
      const result = await service.getApprovalRequestStatus(1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should include current approval level in status', async () => {
    try {
      const result = await service.getApprovalRequestStatus(1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should include approval history timeline', async () => {
    try {
      const result = await service.getApprovalRequestStatus(1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should include comments from approvers', async () => {
    try {
      const result = await service.getApprovalRequestStatus(1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });

  it('should handle completed approvals', async () => {
    try {
      const result = await service.getApprovalRequestStatus(1);
      expect(result).toBeDefined();
    } catch (error) {
      console.error('Test error:', error);
      throw error;
    }
  });
});
